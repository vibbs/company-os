---
name: dev-environment
description: Generates Docker Compose files and dev scripts from tech stack config. Creates environment-specific infrastructure for local development, QA, and production.
user-invokable: true
argument-hint: "[dev | qa | production | reset]"
allowed-tools: Read, Write, Edit, Bash, Grep, Glob
---

# Dev Environment Generator

## Reference
- **ID**: S-ENG-D04
- **Category**: Engineering — DevOps
- **Inputs**: company.config.yaml (tech_stack section), existing docker-compose files
- **Outputs**: Docker Compose files, .env.example, convenience scripts
- **Used by**: User (directly), DevOps Engineer sub-agent
- **Tool scripts**: none (generates files directly)

## Purpose

Read the tech stack from `company.config.yaml` and generate Docker Compose files with environment-specific service configurations, plus convenience shell scripts for starting, stopping, and resetting the dev environment.

## When to Use

- After `/setup` completes — to set up local infrastructure
- When adding a new service to the tech stack (e.g., adding Redis for caching)
- When creating environment-specific configurations (dev, qa, production)
- When resetting the dev environment to a clean state

## Procedure

### Step 1: Read Configuration

Read `company.config.yaml` and extract:

- `company.name` — used as the Docker Compose project name
- `tech_stack.database` — PostgreSQL, MySQL, MongoDB, SQLite
- `tech_stack.cache` — Redis, Memcached, none
- `tech_stack.queue` — BullMQ, RabbitMQ, SQS, none
- `tech_stack.search` — Elasticsearch, Meilisearch, Typesense, none

If the tech stack is empty or unconfigured, advise the user to run `/setup` first.

### Step 2: Check for Existing Files

Scan the project for existing infrastructure files:

- `docker-compose.yml`, `docker-compose.*.yml` in the project root
- `infra/docker-compose.*.yml` in the infra directory
- `Dockerfile` in the project root
- `.env`, `.env.example`, `.env.local`

If existing Docker Compose files are found:
1. Present what was found to the user
2. Offer options: **review** existing files, **merge** new services into them, or **generate alongside** in `infra/`
3. Wait for user decision before proceeding
4. **Never overwrite** existing files without explicit approval

If no existing files are found, proceed to Step 3.

### Step 3: Look Up Current Docker Images

Before generating, use Context7 to verify current best-practice Docker images for each configured service. Fall back to the defaults below if Context7 is unavailable:

| Config Value | Docker Service | Default Image | Default Port |
|---|---|---|---|
| `PostgreSQL` | `postgres` | `postgres:16-alpine` | 5432 |
| `MySQL` | `mysql` | `mysql:8.0` | 3306 |
| `MongoDB` | `mongo` | `mongo:7` | 27017 |
| `Redis` | `redis` | `redis:7-alpine` | 6379 |
| `Memcached` | `memcached` | `memcached:1.6-alpine` | 11211 |
| `RabbitMQ` | `rabbitmq` | `rabbitmq:3-management-alpine` | 5672, 15672 |
| `BullMQ` | (uses Redis) | (reuse redis service) | — |
| `Elasticsearch` | `elasticsearch` | `elasticsearch:8.12.0` | 9200 |
| `Meilisearch` | `meilisearch` | `getmeili/meilisearch:latest` | 7700 |
| `Typesense` | `typesense` | `typesense/typesense:27.1` | 8108 |

### Step 4: Generate Files

Determine the environment from the argument (default: `dev`).

**Always generate these files:**

#### `infra/docker-compose.dev.yml`

```yaml
# Generated by Company OS — /dev-environment
# Services derived from company.config.yaml tech_stack

services:
  # [services based on tech_stack config]
  # Each service includes:
  #   - Named volume for data persistence
  #   - Health check
  #   - Exposed ports (dev only)
  #   - Environment variables referencing .env

volumes:
  # Named volumes for each service
```

**Dev environment specifics:**
- Expose all service ports to localhost
- Use named volumes for data persistence across restarts
- Include health checks for each service
- Set `restart: unless-stopped`
- Use environment variables from `.env` file

#### `.env.example`

Template with all required environment variables:

```bash
# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp_dev
DB_USER=postgres
DB_PASSWORD=postgres

# Cache (if configured)
REDIS_URL=redis://localhost:6379

# Queue (if configured)
# ...
```

#### `tools/dev/start.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail
docker compose -f infra/docker-compose.dev.yml up -d
echo "Dev environment started. Services:"
docker compose -f infra/docker-compose.dev.yml ps
```

#### `tools/dev/stop.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail
docker compose -f infra/docker-compose.dev.yml down
echo "Dev environment stopped."
```

#### `tools/dev/reset.sh`

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "Resetting dev environment (removing volumes)..."
docker compose -f infra/docker-compose.dev.yml down -v
docker compose -f infra/docker-compose.dev.yml up -d
echo "Dev environment reset. Fresh state."
```

**On request** (when argument specifies other environments):

#### `infra/docker-compose.qa.yml`
- Production-like settings
- No exposed ports (services communicate via Docker network only)
- Resource limits defined
- Production image tags

#### `infra/docker-compose.production.yml`
- For VPS deployments via docker-compose
- Restart policies: `always`
- No volume mounts to host
- Production-grade passwords (reference from environment)

### Step 5: Make Scripts Executable

Run `chmod +x tools/dev/start.sh tools/dev/stop.sh tools/dev/reset.sh` to ensure scripts are executable.

### Step 6: Validate (Optional)

If Docker is available on the system, validate the generated compose file:

```bash
docker compose -f infra/docker-compose.dev.yml config
```

If validation fails, fix the issue and re-validate. If Docker is not installed, skip this step and note it in the summary.

### Step 7: Summary

Present what was generated:

```
## Dev Environment Generated

Files created:
  infra/docker-compose.dev.yml    — [N] services configured
  .env.example                    — environment variables template
  tools/dev/start.sh              — start all services
  tools/dev/stop.sh               — stop all services
  tools/dev/reset.sh              — reset to clean state

Services:
  postgres    — localhost:5432 (user: postgres, db: myapp_dev)
  redis       — localhost:6379

Quick start:
  cp .env.example .env            # create your local env file
  bash tools/dev/start.sh         # start services
  bash tools/dev/reset.sh         # reset to clean state
```

## Subcommand: reset

When invoked as `/dev-environment reset`:

1. Check if `infra/docker-compose.dev.yml` exists
2. If yes: run `docker compose -f infra/docker-compose.dev.yml down -v && docker compose -f infra/docker-compose.dev.yml up -d`
3. If no: advise the user to run `/dev-environment` first to generate the files

## Rules

- **Basics only** — generate only the services declared in config. No monitoring, tracing, or observability services unless the user explicitly requests them
- **Shell scripts only** — no Makefiles
- **Never overwrite** existing docker-compose files — always offer to review/merge first
- **Respect VPS deployments** — some users deploy with docker-compose in production, not just local dev
- **SQLite exception** — if database is SQLite, skip the database service (SQLite is file-based, no container needed). Note this in the summary

## Quality Checklist

- [ ] company.config.yaml was read and tech_stack values extracted
- [ ] Existing docker-compose files were checked before generating
- [ ] Docker images are current (verified via Context7 or defaults used)
- [ ] All generated files follow the project's conventions
- [ ] Scripts are executable (chmod +x)
- [ ] .env.example covers all service connection variables
- [ ] Summary shows connection strings for each service
