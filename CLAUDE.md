# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Company OS Overview

This is an **AI Agentic Company OS** — a template project system for building SaaS products with AI-assisted agents, skills, and tools. Users fork this repo, configure `company.config.yaml`, and use the agent system to go from idea → PRD → architecture → implementation → release.

### Three-Layer Architecture

| Layer | Location | Purpose |
|-------|----------|---------|
| **Agents** (Authority) | `.claude/agents/` | Choose what happens next. Route, decide, delegate. |
| **Skills** (Procedural) | `.claude/skills/` | Advise + produce artifacts. Procedures, templates, checklists. |
| **Tools** (Execution) | `tools/` | Execute fixed, deterministic actions. Shell scripts. |

### Dependency Rules
- Agents depend on Skills for *how to think / what to produce*
- Agents depend on Tools for *how to act / what to run*
- Skills may *recommend* tools but never execute them
- Tools never contain reasoning
- **Artifacts are the handshake** between all components

### Importing Existing Work
If artifacts already exist outside Company OS (Google Docs, Notion, local files), run `/artifact-import` to bring them in before starting the ship flow. The import skill classifies documents, adds frontmatter, and links related artifacts so stage gates work from that point forward. Imported artifacts enter at `review` status.

### Canonical Ship Flow
Run `/ship` to kick off the full pipeline. It reads your tech stack from `company.config.yaml`, builds an execution plan, and pauses at each gate for your review.

1. **Orchestrator** routes objective → asks Product Agent for PRD
2. **Product Agent** produces PRD → `artifacts/prds/`
3. **Engineering Agent** produces RFC/API contract → `artifacts/rfcs/`
4. **Ops & Risk Agent** reviews RFC for security/privacy
5. **Engineering Agent** implements → runs CI tools → **Seed & Verify** (presents start commands, service URLs, seed data for developer testing)
6. **QA & Release Agent** produces test plan + QA report → `artifacts/qa-reports/`
7. **Growth Agent** produces launch assets → `artifacts/launch-briefs/`
8. **Orchestrator** checks all gates → approves release

### First-Time Setup
For new projects or existing repos, run `/setup` to configure Company OS interactively. The wizard fills in `company.config.yaml`, generates `.claude/settings.json` with tech-stack-specific permissions, and scaffolds directories. Alternatively, run `bash setup.sh` for a non-interactive scaffold.

### Upgrading
Run `/upgrade-company-os` to check for updates, preview changes, upgrade, or rollback. The installer uses semantic versioning and manifest-based conflict detection to safely update template files without losing user customizations. Run `/upgrade-company-os check` to see release notes.

### Key Files
- `company.config.yaml` — company-specific tech stack, API standards, conventions. **Read this first in every session.**
- `setup.sh` — bash setup fallback for scaffolding directories and template config
- `imports/` — **transient** staging for `/artifact-import` (files are classified, moved to `artifacts/`, then deleted)
- `standards/` — **permanent** reference docs agents read continuously (stays in place after `/ingest`)
- `artifacts/` — agent-produced outputs with YAML frontmatter and lineage tracking
- `seeds/` — test seed data and fixtures generated by `/seed-data` (scenarios: nominal, edge-cases, empty, high-volume, minimal, error-states)
- `.company-os/` — internal Company OS system files (version, manifest, migrations, backups)
- `tasks/todo.md` — current session task tracking
- `tasks/lessons.md` — accumulated corrections and patterns

### Artifact Lineage & Enforcement
Every artifact has YAML frontmatter with: `id`, `type`, `status` (draft/review/approved/archived), `parent`, `children`, `depends_on`, `blocks`. Always maintain these links when creating or updating artifacts.

**Enforcement tools** (use these — don't skip them):
- `./tools/artifact/validate.sh` — checks frontmatter + verifies parent/depends_on/children references exist
- `./tools/artifact/link.sh` — links parent↔child artifacts (edits both files)
- `./tools/artifact/promote.sh` — status transitions with ordering enforcement (draft→review→approved)
- `./tools/artifact/check-gate.sh` — stage gate checks (prd-to-rfc, rfc-to-impl, impl-to-qa, release). **Stage-aware**: reads `company.stage` from config — `idea` stage makes all gates advisory (warnings only), `mvp` enforces core gates only, `growth`/`scale` enforces all.

### Hooks
Two command-type hooks run automatically (zero token cost):
- **Pre-promote validation**: Auto-runs `validate.sh` before `promote.sh` — blocks promotion of invalid artifacts
- **Post-write frontmatter check**: Warns when files written to `artifacts/` lack YAML frontmatter

### Ingest Command
After placing new files in `standards/` or `artifacts/`, run `/ingest` to detect changes and update relevant skills/agents.

### Tech Stack Awareness
Always read `company.config.yaml` before making technical recommendations. If the configured tech stack is suboptimal for the task at hand, **flag it explicitly** with a recommendation and rationale — but respect the user's final decision.

---

## Workflow Orchestration

### 1. Plan Mode Default
- Enter plan mode for ANY non-trivial task (3+ steps or architectural decisions)
- If something goes sideways, STOP and re-plan immediately — don't keep pushing
- Use plan mode for verification steps, not just building
- Write detailed specs upfront to reduce ambiguity

### 2. Subagent Strategy
- Use subagents liberally to keep main context window clean
- Offload research, exploration, and parallel analysis to subagents
- For complex problems, throw more compute at it via subagents
- One task per subagent for focused execution

### 3. Self-Improvement Loop
- After ANY correction from the user: update `tasks/lessons.md` with the pattern
- Write rules for yourself that prevent the same mistake
- Ruthlessly iterate on these lessons until mistake rate drops
- Review lessons at session start for relevant project

### 4. Verification Before Done
- Never mark a task complete without proving it works
- Diff behavior between main and your changes when relevant
- Ask yourself: "Would a staff engineer approve this?"
- Run tests, check logs, demonstrate correctness

### 5. Demand Elegance (Balanced)
- For non-trivial changes: pause and ask "is there a more elegant way?"
- If a fix feels hacky: "Knowing everything I know now, implement the elegant solution"
- Skip this for simple, obvious fixes — don't over-engineer
- Challenge your own work before presenting it

### 7. System Maintenance
- After ANY change to the Company OS structure (skills, agents, tools, artifact types, stage gates):
  run the `system-maintenance` skill to audit and update all documentation
- Trigger conditions: new/deleted/renamed skill, agent, or tool; modified validate.sh or check-gate.sh
- Documentation files that must stay in sync: CLAUDE.md, .company-os/docs/SETUP.md, all agent .md files
- This is not optional — stale docs cause cascading confusion for agents and users

### 6. Autonomous Bug Fixing
- When given a bug report: just fix it. Don't ask for hand-holding
- Point at logs, errors, failing tests — then resolve them
- Zero context switching required from the user
- Go fix failing CI tests without being told how

### 8. Git Discipline
- **Commit early, commit often** — make logical, atomic commits as you complete each meaningful unit of work
- **Read `conventions.commit_style`** from `company.config.yaml` before your first commit:
  - `conventional`: `feat:`, `fix:`, `refactor:`, `docs:`, `chore:`, `test:` prefixes
  - `gitmoji`: emoji-prefixed commits
  - `freeform`: no enforced format, but keep messages clear and descriptive
- **One concern per commit** — don't mix unrelated changes. A bug fix, a new feature, and a refactor are three separate commits
- **Commit message format**: first line is a concise summary (≤72 chars), blank line, then body explaining *why* not *what*
- **Commit boundaries during feature development**:
  - After scaffolding / boilerplate setup
  - After each logical component or module is complete
  - After tests pass for a unit of work
  - After documentation updates
  - Before and after risky refactors
- **Never leave uncommitted work** at the end of a task — if the user asked you to build something, commit the result
- **Branch strategy**: read `conventions.branching` from config. Default to feature branches off main unless told otherwise
- **Version bump before push** (Company OS repo only): Before pushing to remote, always check if `VERSION` and `CHANGELOG.md` reflect the changes being pushed. If new features were added → MINOR bump. If only bug fixes → PATCH bump. If breaking changes → MAJOR bump. Move the `[Unreleased]` section in CHANGELOG.md to a versioned heading with today's date. Never push unversioned feature work.

### 9. Library Documentation (Context7)
- **Before using any library or framework API**, fetch current documentation via Context7:
  1. Call `resolve-library-id` with the library name to get the Context7 ID
  2. Call `query-docs` with the ID and your specific question
- This applies to: architecture decisions, API design, implementation, and dependency upgrades
- Never assume training data is current — always verify against live docs for:
  - Installation and setup patterns
  - API signatures and configuration options
  - Breaking changes between versions
- If Context7 is unavailable, note it explicitly and flag which APIs may need verification

## Task Management

1. **Plan First**: Write plan to `tasks/todo.md` with checkable items
2. **Verify Plan**: Check in before starting implementation
3. **Track Progress**: Mark items complete as you go
4. **Explain Changes**: High-level summary at each step
5. **Document Results**: Add review section to `tasks/todo.md`
6. **Capture Lessons**: Update `tasks/lessons.md` after corrections

## Core Principles

- **Simplicity First**: Make every change as simple as possible. Impact minimal code.
- **No Laziness**: Find root causes. No temporary fixes. Senior developer standards.
- **Minimal Impact**: Changes should only touch what's necessary. Avoid introducing bugs.
